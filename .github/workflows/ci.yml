# This workflow will install Python dependencies, run tests with 3 versions of Python

name: FastApi application on Docker container. Test. Lint. Format.

on:
  push:
    branches: [ "dev", "main" ]
  pull_request:
    branches: [ "main" ]


jobs:
#  install-dependencies:
#    runs-on: ubuntu-latest
#    strategy:
#      matrix:
#        python-version: ["3.10", "3.11", "3.12"]
#    steps:
#    - name: Checkout code
#      uses: actions/checkout@v4
#
#    - name: Setup Python
#      uses: actions/setup-python@v5
#      with:
#        python-version: ${{ matrix.python-version }}
#        cache-dependency-path: pyproject.toml
#
#    - run: python -m pip install --upgrade pip
#
#    - name: Install Poetry
#      uses: abatilo/actions-poetry@v3
#
#    - uses: actions/cache@v4
#      id: cache
#      with:
#        path: ${{ env.pythonLocation }}
#        key: ${{ runner.os }}-python-${{ env.pythonLocation }}-${{ matrix.python-version }}-${{ hashFiles('pyproject.toml') }}  # Modified caching key
#
#    - name: Install dependencies
#      if: steps.cache.outputs.cache-hit != 'true'
#      run: poetry install --no-root
#
#
#  quality:
#    needs: install-dependencies
#    runs-on: ubuntu-latest
#    strategy:
#      matrix:
#        python-version: ["3.10", "3.11", "3.12"]
#    steps:
#    - name: Checkout code
#      uses: actions/checkout@v4
#
#    - name: Setup Python
#      uses: actions/setup-python@v5
#      with:
#        python-version: ${{ matrix.python-version }}
#        cache-dependency-path: pyproject.toml
#
#    - run: python -m pip install --upgrade pip
#
#    - name: Install Poetry
#      uses: abatilo/actions-poetry@v3
#
#    - uses: actions/cache@v4
#      id: cache
#      with:
#        path: ${{ env.pythonLocation }}
#        key: ${{ runner.os }}-python-${{ env.pythonLocation }}-${{ matrix.python-version }}-${{ hashFiles('pyproject.toml') }}
#
#    - name: Install dependencies
#      run: poetry install # --no-root
#
#    - name: Format code with Black
#      run: poetry run black --check .
#
#    - name: Run mypy
#      run: poetry run mypy app_repo processor_repo
#
#    - name: Run pylint
#      run: |
#       poetry run pylint $(git ls-files '*.py' | grep -v '/tests/')

#  docker_registry:
#    name: Push Docker images to Docker Hub
#    runs-on: ubuntu-latest
#    steps:
#      - name: Checkout
#        uses: actions/checkout@v4
#
#      - name: Log in to Docker Hub
#        uses: docker/login-action@v3
#        with:
#          username: ${{ secrets.DOCKER_USERNAME }}
#          password: ${{ secrets.DOCKER_PASSWORD }}
#
#      - name: App Docker metadata (tags, labels)
#        id: app-meta
#        uses: docker/metadata-action@v5
#        with:
#          images: osherkoren/fastapi-app
#
#      - name: Build and push App Docker image
#        uses: docker/build-push-action@v5
#        with:
#          context: ./app_repo
#          file: ./app_repo/Dockerfile
##          push: true
#          push: ${{ github.event_name != 'pull_request' }}
#          tags: ${{ steps.app-meta.outputs.tags }}
#          labels: ${{ steps.app-meta.outputs.labels }}
#
#      - name: Processor Docker metadata (tags, labels)
#        id: processor-meta
#        uses: docker/metadata-action@v5
#        with:
#          images: osherkoren/kafka-processor
#
#      - name: Build and push Processor Docker image
#        uses: docker/build-push-action@v5
#        with:
#            context: ./processor_repo
#            file: ./processor_repo/Dockerfile
#            push: ${{ github.event_name != 'pull_request' }}
#            tags: ${{ steps.processor-meta.outputs.tags }}
#            labels: ${{ steps.processor-meta.outputs.labels }}

  tests:
#    needs: quality
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Print real values of secrets and variables
        run: |
          echo "PS_USER: ${{ secrets.PS_USER }}"
          echo "PS_PASSWORD: ${{ secrets.PS_PASSWORD }}"
          echo "PS_HOST_DEV: ${{ vars.PS_HOST_DEV }}"
          echo "PS_PORT: ${{ vars.PS_PORT_DEV }}"
          echo "PS_DB_DEV: ${{ vars.PS_DB_DEV }}"

      - name: Start services with Docker Compose
        id: start_services
        run: docker-compose -f docker-compose-dev.yml --env-file ./.env.ci up -d

#      - name: Log if services started with errors
#        if: steps.start_services.outcome != 'success'
#        run: docker-compose -f docker-compose-dev.yml --env-file ./.env.ci logs

      - name: Log dev-app service output
        if: always()
        run: docker-compose -f docker-compose-dev.yml --env-file ./.env.ci logs dev-app

      - name: Log dev-processor service output
        if: always()
        run: docker-compose -f docker-compose-dev.yml --env-file ./.env.ci logs dev-processor

      - name: Wait for services to be healthy
        if: always()
        run: |
          docker-compose -f docker-compose-dev.yml --env-file ./.env.ci ps -q | xargs docker inspect --format='{{.State.Health.Status}}'

      - name: List Docker containers
        if: always()
        run: docker ps

#      - name: Log dev-db service output on failure
#        if: failure()
#        run: docker-compose -f docker-compose-dev.yml --env-file ./.env.ci logs dev-db
#
#      - name: Log dev-app service output on failure
#        if: failure()
#        run: docker-compose -f docker-compose-dev.yml --env-file ./.env.ci logs dev-app
#
#      - name: Wait for services to be healthy
#        if: always()
#        run: docker-compose -f docker-compose-dev.yml --env-file ./.env.ci ps -q | xargs docker inspect --format='{{.State.Health.Status}}' | grep -q healthy


#      - name: Log dev-app service output
#        if: steps.start_services.outcome == 'failure'
#        run: docker-compose -f docker-compose-dev.yml logs -f dev-app

      - name: Run tests
        if: steps.start_services.outcome == 'success'
        run: docker-compose -f docker-compose-dev.yml exec play_with_fastapi-dev-app-1 pytest tests/
